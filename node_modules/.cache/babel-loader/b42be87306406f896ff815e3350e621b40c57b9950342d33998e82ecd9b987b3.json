{"ast":null,"code":"\"use strict\";\n\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateSessionFromResponse = exports.applySession = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = void 0;\nconst util_1 = require(\"util\");\nconst bson_1 = require(\"./bson\");\nconst metrics_1 = require(\"./cmap/metrics\");\nconst shared_1 = require(\"./cmap/wire_protocol/shared\");\nconst constants_1 = require(\"./constants\");\nconst error_1 = require(\"./error\");\nconst mongo_types_1 = require(\"./mongo_types\");\nconst execute_operation_1 = require(\"./operations/execute_operation\");\nconst run_command_1 = require(\"./operations/run_command\");\nconst read_concern_1 = require(\"./read_concern\");\nconst read_preference_1 = require(\"./read_preference\");\nconst common_1 = require(\"./sdam/common\");\nconst transactions_1 = require(\"./transactions\");\nconst utils_1 = require(\"./utils\");\nconst write_concern_1 = require(\"./write_concern\");\nconst minWireVersionForShardedTransactions = 8;\n/** @internal */\nconst kServerSession = Symbol('serverSession');\n/** @internal */\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\nconst kPinnedConnection = Symbol('pinnedConnection');\n/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */\nconst kTxnNumberIncrement = Symbol('txnNumberIncrement');\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\nclass ClientSession extends mongo_types_1.TypedEventEmitter {\n  /**\n   * Create a client session.\n   * @internal\n   * @param client - The current client\n   * @param sessionPool - The server session pool (Internal Class)\n   * @param options - Optional settings\n   * @param clientOptions - Optional settings provided when creating a MongoClient\n   */\n  constructor(client, sessionPool, options, clientOptions) {\n    super();\n    /** @internal */\n    this[_a] = false;\n    if (client == null) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a MongoClient');\n    }\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');\n    }\n    options = options ?? {};\n    if (options.snapshot === true) {\n      this[kSnapshotEnabled] = true;\n      if (options.causalConsistency === true) {\n        throw new error_1.MongoInvalidArgumentError('Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive');\n      }\n    }\n    this.client = client;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n    this.explicit = !!options.explicit;\n    this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;\n    this[kTxnNumberIncrement] = 0;\n    const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;\n    this.supports = {\n      // if we can enable causal consistency, do so by default\n      causalConsistency: options.causalConsistency ?? defaultCausalConsistencyValue\n    };\n    this.clusterTime = options.initialClusterTime;\n    this.operationTime = undefined;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    this.transaction = new transactions_1.Transaction();\n  }\n  /** The server id associated with this session */\n  get id() {\n    return this[kServerSession]?.id;\n  }\n  get serverSession() {\n    let serverSession = this[kServerSession];\n    if (serverSession == null) {\n      if (this.explicit) {\n        throw new error_1.MongoRuntimeError('Unexpected null serverSession for an explicit session');\n      }\n      if (this.hasEnded) {\n        throw new error_1.MongoRuntimeError('Unexpected null serverSession for an ended implicit session');\n      }\n      serverSession = this.sessionPool.acquire();\n      this[kServerSession] = serverSession;\n    }\n    return serverSession;\n  }\n  /** Whether or not this session is configured for snapshot reads */\n  get snapshotEnabled() {\n    return this[kSnapshotEnabled];\n  }\n  get loadBalanced() {\n    return this.client.topology?.description.type === common_1.TopologyType.LoadBalanced;\n  }\n  /** @internal */\n  get pinnedConnection() {\n    return this[kPinnedConnection];\n  }\n  /** @internal */\n  pin(conn) {\n    if (this[kPinnedConnection]) {\n      throw TypeError('Cannot pin multiple connections to the same session');\n    }\n    this[kPinnedConnection] = conn;\n    conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n  }\n  /** @internal */\n  unpin(options) {\n    if (this.loadBalanced) {\n      return maybeClearPinnedConnection(this, options);\n    }\n    this.transaction.unpinServer();\n  }\n  get isPinned() {\n    return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n  }\n  /**\n   * Ends this session on the server\n   *\n   * @param options - Optional settings. Currently reserved for future use\n   */\n  async endSession(options) {\n    try {\n      if (this.inTransaction()) {\n        await this.abortTransaction();\n      }\n      if (!this.hasEnded) {\n        const serverSession = this[kServerSession];\n        if (serverSession != null) {\n          // release the server session back to the pool\n          this.sessionPool.release(serverSession);\n          // Make sure a new serverSession never makes it onto this ClientSession\n          Object.defineProperty(this, kServerSession, {\n            value: ServerSession.clone(serverSession),\n            writable: false\n          });\n        }\n        // mark the session as ended, and emit a signal\n        this.hasEnded = true;\n        this.emit('ended', this);\n      }\n    } catch {\n      // spec indicates that we should ignore all errors for `endSessions`\n    } finally {\n      maybeClearPinnedConnection(this, {\n        force: true,\n        ...options\n      });\n    }\n  }\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n  advanceOperationTime(operationTime) {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n  /**\n   * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n   *\n   * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n   */\n  advanceClusterTime(clusterTime) {\n    if (!clusterTime || typeof clusterTime !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');\n    }\n    if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n      throw new error_1.MongoInvalidArgumentError('input cluster time \"clusterTime\" property must be a valid BSON Timestamp');\n    }\n    if (!clusterTime.signature || clusterTime.signature.hash?._bsontype !== 'Binary' || typeof clusterTime.signature.keyId !== 'bigint' && typeof clusterTime.signature.keyId !== 'number' && clusterTime.signature.keyId?._bsontype !== 'Long' // apparently we decode the key to number?\n    ) {\n      throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId');\n    }\n    (0, common_1._advanceClusterTime)(this, clusterTime);\n  }\n  /**\n   * Used to determine if this session equals another\n   *\n   * @param session - The session to compare to\n   */\n  equals(session) {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n    if (this.id == null || session.id == null) {\n      return false;\n    }\n    return utils_1.ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);\n  }\n  /**\n   * Increment the transaction number on the internal ServerSession\n   *\n   * @privateRemarks\n   * This helper increments a value stored on the client session that will be\n   * added to the serverSession's txnNumber upon applying it to a command.\n   * This is because the serverSession is lazily acquired after a connection is obtained\n   */\n  incrementTransactionNumber() {\n    this[kTxnNumberIncrement] += 1;\n  }\n  /** @returns whether this session is currently in a transaction or not */\n  inTransaction() {\n    return this.transaction.isActive;\n  }\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @param options - Options for the transaction\n   */\n  startTransaction(options) {\n    if (this[kSnapshotEnabled]) {\n      throw new error_1.MongoCompatibilityError('Transactions are not supported in snapshot sessions');\n    }\n    if (this.inTransaction()) {\n      throw new error_1.MongoTransactionError('Transaction already in progress');\n    }\n    if (this.isPinned && this.transaction.isCommitted) {\n      this.unpin();\n    }\n    const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);\n    if ((0, shared_1.isSharded)(this.client.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n      throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n    }\n    // increment txnNumber\n    this.incrementTransactionNumber();\n    // create transaction state\n    this.transaction = new transactions_1.Transaction({\n      readConcern: options?.readConcern ?? this.defaultTransactionOptions.readConcern ?? this.clientOptions?.readConcern,\n      writeConcern: options?.writeConcern ?? this.defaultTransactionOptions.writeConcern ?? this.clientOptions?.writeConcern,\n      readPreference: options?.readPreference ?? this.defaultTransactionOptions.readPreference ?? this.clientOptions?.readPreference,\n      maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS\n    });\n    this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);\n  }\n  /**\n   * Commits the currently active transaction in this session.\n   */\n  async commitTransaction() {\n    return endTransactionAsync(this, 'commitTransaction');\n  }\n  /**\n   * Aborts the currently active transaction in this session.\n   */\n  async abortTransaction() {\n    return endTransactionAsync(this, 'abortTransaction');\n  }\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   */\n  toBSON() {\n    throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n  }\n  /**\n   * Starts a transaction and runs a provided function, ensuring the commitTransaction is always attempted when all operations run in the function have completed.\n   *\n   * **IMPORTANT:** This method requires the user to return a Promise, and `await` all operations.\n   *\n   * @remarks\n   * This function:\n   * - If all operations successfully complete and the `commitTransaction` operation is successful, then this function will return the result of the provided function.\n   * - If the transaction is unable to complete or an error is thrown from within the provided function, then this function will throw an error.\n   *   - If the transaction is manually aborted within the provided function it will not throw.\n   * - May be called multiple times if the driver needs to attempt to retry the operations.\n   *\n   * Checkout a descriptive example here:\n   * @see https://www.mongodb.com/blog/post/quick-start-nodejs--mongodb--how-to-implement-transactions\n   *\n   * @param fn - callback to run within a transaction\n   * @param options - optional settings for the transaction\n   * @returns A raw command response or undefined\n   */\n  async withTransaction(fn, options) {\n    const startTime = (0, utils_1.now)();\n    return attemptTransaction(this, startTime, fn, options);\n  }\n}\nexports.ClientSession = ClientSession;\n_a = kSnapshotEnabled;\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);\nfunction hasNotTimedOut(startTime, max) {\n  return (0, utils_1.calculateDurationInMs)(startTime) < max;\n}\nfunction isUnknownTransactionCommitResult(err) {\n  const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n  return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;\n}\nfunction maybeClearPinnedConnection(session, options) {\n  // unpin a connection if it has been pinned\n  const conn = session[kPinnedConnection];\n  const error = options?.error;\n  if (session.inTransaction() && error && error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n    return;\n  }\n  const topology = session.client.topology;\n  // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n  //       to validate that we don't unpin on _all_ errors?\n  if (conn && topology != null) {\n    const servers = Array.from(topology.s.servers.values());\n    const loadBalancer = servers[0];\n    if (options?.error == null || options?.force) {\n      loadBalancer.pool.checkIn(conn);\n      conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n      if (options?.forceClear) {\n        loadBalancer.pool.clear({\n          serviceId: conn.serviceId\n        });\n      }\n    }\n    session[kPinnedConnection] = undefined;\n  }\n}\nexports.maybeClearPinnedConnection = maybeClearPinnedConnection;\nfunction isMaxTimeMSExpiredError(err) {\n  if (err == null || !(err instanceof error_1.MongoServerError)) {\n    return false;\n  }\n  return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;\n}\nfunction attemptTransactionCommit(session, startTime, fn, result, options) {\n  return session.commitTransaction().then(() => result, err => {\n    if (err instanceof error_1.MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {\n      if (err.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult)) {\n        return attemptTransactionCommit(session, startTime, fn, result, options);\n      }\n      if (err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n    throw err;\n  });\n}\nconst USER_EXPLICIT_TXN_END_STATES = new Set([transactions_1.TxnState.NO_TRANSACTION, transactions_1.TxnState.TRANSACTION_COMMITTED, transactions_1.TxnState.TRANSACTION_ABORTED]);\nfunction userExplicitlyEndedTransaction(session) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\nfunction attemptTransaction(session, startTime, fn, options = {}) {\n  session.startTransaction(options);\n  let promise;\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n  if (!(0, utils_1.isPromiseLike)(promise)) {\n    session.abortTransaction().catch(() => null);\n    return Promise.reject(new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise'));\n  }\n  return promise.then(result => {\n    if (userExplicitlyEndedTransaction(session)) {\n      return result;\n    }\n    return attemptTransactionCommit(session, startTime, fn, result, options);\n  }, err => {\n    function maybeRetryOrThrow(err) {\n      if (err instanceof error_1.MongoError && err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n      if (isMaxTimeMSExpiredError(err)) {\n        err.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n      }\n      throw err;\n    }\n    if (session.inTransaction()) {\n      return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n    }\n    return maybeRetryOrThrow(err);\n  });\n}\nconst endTransactionAsync = (0, util_1.promisify)(endTransaction);\nfunction endTransaction(session, commandName, callback) {\n  // handle any initial problematic cases\n  const txnState = session.transaction.state;\n  if (txnState === transactions_1.TxnState.NO_TRANSACTION) {\n    callback(new error_1.MongoTransactionError('No transaction started'));\n    return;\n  }\n  if (commandName === 'commitTransaction') {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback();\n      return;\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction'));\n      return;\n    }\n  } else {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      callback();\n      return;\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction twice'));\n      return;\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction'));\n      return;\n    }\n  }\n  // construct and send the command\n  const command = {\n    [commandName]: 1\n  };\n  // apply a writeConcern if specified\n  let writeConcern;\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.writeConcern) {\n    writeConcern = {\n      w: session.clientOptions.writeConcern.w\n    };\n  }\n  if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({\n      wtimeoutMS: 10000\n    }, writeConcern, {\n      w: 'majority'\n    });\n  }\n  if (writeConcern) {\n    write_concern_1.WriteConcern.apply(command, writeConcern);\n  }\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, {\n      maxTimeMS: session.transaction.options.maxTimeMS\n    });\n  }\n  function commandHandler(error) {\n    if (commandName !== 'commitTransaction') {\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      if (session.loadBalanced) {\n        maybeClearPinnedConnection(session, {\n          force: false\n        });\n      }\n      // The spec indicates that we should ignore all errors on `abortTransaction`\n      return callback();\n    }\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n    if (error instanceof error_1.MongoError) {\n      if ((0, error_1.isRetryableWriteError)(error) || error instanceof error_1.MongoWriteConcernError || isMaxTimeMSExpiredError(error)) {\n        if (isUnknownTransactionCommitResult(error)) {\n          error.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n          // per txns spec, must unpin session in this case\n          session.unpin({\n            error\n          });\n        }\n      } else if (error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n        session.unpin({\n          error\n        });\n      }\n    }\n    callback(error);\n  }\n  if (session.transaction.recoveryToken) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  }\n  // send the command\n  (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(command, {\n    session,\n    readPreference: read_preference_1.ReadPreference.primary,\n    bypassPinningCheck: true\n  }), error => {\n    if (command.abortTransaction) {\n      // always unpin on abort regardless of command outcome\n      session.unpin();\n    }\n    if (error instanceof error_1.MongoError && (0, error_1.isRetryableWriteError)(error)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.unpin({\n          force: true\n        });\n        command.writeConcern = Object.assign({\n          wtimeout: 10000\n        }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n      return (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(command, {\n        session,\n        readPreference: read_preference_1.ReadPreference.primary,\n        bypassPinningCheck: true\n      }), commandHandler);\n    }\n    commandHandler(error);\n  });\n}\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\nclass ServerSession {\n  /** @internal */\n  constructor() {\n    this.id = {\n      id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID)\n    };\n    this.lastUse = (0, utils_1.now)();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n  hasTimedOut(sessionTimeoutMinutes) {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000 % 3600000 / 60000);\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n  /**\n   * @internal\n   * Cloning meant to keep a readable reference to the server session data\n   * after ClientSession has ended\n   */\n  static clone(serverSession) {\n    const arrayBuffer = new ArrayBuffer(16);\n    const idBytes = Buffer.from(arrayBuffer);\n    idBytes.set(serverSession.id.id.buffer);\n    const id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type);\n    // Manual prototype construction to avoid modifying the constructor of this class\n    return Object.setPrototypeOf({\n      id: {\n        id\n      },\n      lastUse: serverSession.lastUse,\n      txnNumber: serverSession.txnNumber,\n      isDirty: serverSession.isDirty\n    }, ServerSession.prototype);\n  }\n}\nexports.ServerSession = ServerSession;\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\nclass ServerSessionPool {\n  constructor(client) {\n    if (client == null) {\n      throw new error_1.MongoRuntimeError('ServerSessionPool requires a MongoClient');\n    }\n    this.client = client;\n    this.sessions = new utils_1.List();\n  }\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\n   */\n  acquire() {\n    const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n    let session = null;\n    // Try to obtain from session pool\n    while (this.sessions.length > 0) {\n      const potentialSession = this.sessions.shift();\n      if (potentialSession != null && (!!this.client.topology?.loadBalanced || !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {\n        session = potentialSession;\n        break;\n      }\n    }\n    // If nothing valid came from the pool make a new one\n    if (session == null) {\n      session = new ServerSession();\n    }\n    return session;\n  }\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   *\n   * @param session - The session to release to the pool\n   */\n  release(session) {\n    const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n    if (this.client.topology?.loadBalanced && !sessionTimeoutMinutes) {\n      this.sessions.unshift(session);\n    }\n    if (!sessionTimeoutMinutes) {\n      return;\n    }\n    this.sessions.prune(session => session.hasTimedOut(sessionTimeoutMinutes));\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      }\n      // otherwise, readd this session to the session pool\n      this.sessions.unshift(session);\n    }\n  }\n}\nexports.ServerSessionPool = ServerSessionPool;\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n *\n * @internal\n */\nfunction applySession(session, command, options) {\n  if (session.hasEnded) {\n    return new error_1.MongoExpiredSessionError();\n  }\n  // May acquire serverSession here\n  const serverSession = session.serverSession;\n  if (serverSession == null) {\n    return new error_1.MongoRuntimeError('Unable to acquire server session');\n  }\n  if (options.writeConcern?.w === 0) {\n    if (session && session.explicit) {\n      // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)\n      return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');\n    }\n    return;\n  }\n  // mark the last use of this session, and apply the `lsid`\n  serverSession.lastUse = (0, utils_1.now)();\n  command.lsid = serverSession.id;\n  const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);\n  const isRetryableWrite = !!options.willRetryWrite;\n  if (isRetryableWrite || inTxnOrTxnCommand) {\n    serverSession.txnNumber += session[kTxnNumberIncrement];\n    session[kTxnNumberIncrement] = 0;\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);\n  }\n  if (!inTxnOrTxnCommand) {\n    if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {\n      session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);\n    }\n    if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command)) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || {\n        level: read_concern_1.ReadConcernLevel.snapshot\n      };\n      if (session[kSnapshotTime] != null) {\n        Object.assign(command.readConcern, {\n          atClusterTime: session[kSnapshotTime]\n        });\n      }\n    }\n    return;\n  }\n  // now attempt to apply transaction-specific sessions data\n  // `autocommit` must always be false to differentiate from retryable writes\n  command.autocommit = false;\n  if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    const readConcern = session.transaction.options.readConcern || session?.clientOptions?.readConcern;\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n  return;\n}\nexports.applySession = applySession;\nfunction updateSessionFromResponse(session, document) {\n  if (document.$clusterTime) {\n    (0, common_1._advanceClusterTime)(session, document.$clusterTime);\n  }\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n  if (session?.[kSnapshotEnabled] && session[kSnapshotTime] == null) {\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    const atClusterTime = document.cursor?.atClusterTime || document.atClusterTime;\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}\nexports.updateSessionFromResponse = updateSessionFromResponse;","map":{"version":3,"names":["_a","Object","defineProperty","exports","value","updateSessionFromResponse","applySession","ServerSessionPool","ServerSession","maybeClearPinnedConnection","ClientSession","util_1","require","bson_1","metrics_1","shared_1","constants_1","error_1","mongo_types_1","execute_operation_1","run_command_1","read_concern_1","read_preference_1","common_1","transactions_1","utils_1","write_concern_1","minWireVersionForShardedTransactions","kServerSession","Symbol","kSnapshotTime","kSnapshotEnabled","kPinnedConnection","kTxnNumberIncrement","TypedEventEmitter","constructor","client","sessionPool","options","clientOptions","MongoRuntimeError","snapshot","causalConsistency","MongoInvalidArgumentError","hasEnded","explicit","acquire","defaultCausalConsistencyValue","supports","clusterTime","initialClusterTime","operationTime","undefined","owner","defaultTransactionOptions","assign","transaction","Transaction","id","serverSession","snapshotEnabled","loadBalanced","topology","description","type","TopologyType","LoadBalanced","pinnedConnection","pin","conn","TypeError","emit","PINNED","inTransaction","ConnectionPoolMetrics","TXN","CURSOR","unpin","unpinServer","isPinned","endSession","abortTransaction","release","clone","writable","force","advanceOperationTime","greaterThan","advanceClusterTime","_bsontype","signature","hash","keyId","_advanceClusterTime","equals","session","ByteUtils","buffer","incrementTransactionNumber","isActive","startTransaction","MongoCompatibilityError","MongoTransactionError","isCommitted","topologyMaxWireVersion","maxWireVersion","isSharded","readConcern","writeConcern","readPreference","maxCommitTimeMS","transition","TxnState","STARTING_TRANSACTION","commitTransaction","endTransactionAsync","toBSON","withTransaction","fn","startTime","now","attemptTransaction","MAX_WITH_TRANSACTION_TIMEOUT","NON_DETERMINISTIC_WRITE_CONCERN_ERRORS","Set","hasNotTimedOut","max","calculateDurationInMs","isUnknownTransactionCommitResult","err","isNonDeterministicWriteConcernError","MongoServerError","codeName","has","isMaxTimeMSExpiredError","code","MONGODB_ERROR_CODES","UnsatisfiableWriteConcern","UnknownReplWriteConcern","error","MongoError","hasErrorLabel","MongoErrorLabel","TransientTransactionError","servers","Array","from","s","values","loadBalancer","pool","checkIn","UNPINNED","state","NO_TRANSACTION","forceClear","clear","serviceId","MaxTimeMSExpired","writeConcernError","attemptTransactionCommit","result","then","UnknownTransactionCommitResult","USER_EXPLICIT_TXN_END_STATES","TRANSACTION_COMMITTED","TRANSACTION_ABORTED","userExplicitlyEndedTransaction","promise","Promise","reject","isPromiseLike","catch","maybeRetryOrThrow","addErrorLabel","promisify","endTransaction","commandName","callback","txnState","TRANSACTION_COMMITTED_EMPTY","command","w","wtimeoutMS","WriteConcern","apply","maxTimeMS","commandHandler","isRetryableWriteError","MongoWriteConcernError","recoveryToken","executeOperation","RunAdminCommandOperation","ReadPreference","primary","bypassPinningCheck","wtimeout","Binary","uuidV4","SUBTYPE_UUID","lastUse","txnNumber","isDirty","hasTimedOut","sessionTimeoutMinutes","idleTimeMinutes","Math","round","arrayBuffer","ArrayBuffer","idBytes","Buffer","set","sub_type","setPrototypeOf","prototype","sessions","List","logicalSessionTimeoutMinutes","length","potentialSession","shift","unshift","prune","MongoExpiredSessionError","MongoAPIError","lsid","inTxnOrTxnCommand","isTransactionCommand","isRetryableWrite","willRetryWrite","Long","fromNumber","commandSupportsReadConcern","afterClusterTime","level","ReadConcernLevel","atClusterTime","autocommit","TRANSACTION_IN_PROGRESS","document","$clusterTime","_recoveryToken","cursor"],"sources":["D:/web_project/node_modules/mongodb/lib/sessions.js"],"sourcesContent":["\"use strict\";\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.updateSessionFromResponse = exports.applySession = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = void 0;\nconst util_1 = require(\"util\");\nconst bson_1 = require(\"./bson\");\nconst metrics_1 = require(\"./cmap/metrics\");\nconst shared_1 = require(\"./cmap/wire_protocol/shared\");\nconst constants_1 = require(\"./constants\");\nconst error_1 = require(\"./error\");\nconst mongo_types_1 = require(\"./mongo_types\");\nconst execute_operation_1 = require(\"./operations/execute_operation\");\nconst run_command_1 = require(\"./operations/run_command\");\nconst read_concern_1 = require(\"./read_concern\");\nconst read_preference_1 = require(\"./read_preference\");\nconst common_1 = require(\"./sdam/common\");\nconst transactions_1 = require(\"./transactions\");\nconst utils_1 = require(\"./utils\");\nconst write_concern_1 = require(\"./write_concern\");\nconst minWireVersionForShardedTransactions = 8;\n/** @internal */\nconst kServerSession = Symbol('serverSession');\n/** @internal */\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\nconst kPinnedConnection = Symbol('pinnedConnection');\n/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */\nconst kTxnNumberIncrement = Symbol('txnNumberIncrement');\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\nclass ClientSession extends mongo_types_1.TypedEventEmitter {\n    /**\n     * Create a client session.\n     * @internal\n     * @param client - The current client\n     * @param sessionPool - The server session pool (Internal Class)\n     * @param options - Optional settings\n     * @param clientOptions - Optional settings provided when creating a MongoClient\n     */\n    constructor(client, sessionPool, options, clientOptions) {\n        super();\n        /** @internal */\n        this[_a] = false;\n        if (client == null) {\n            // TODO(NODE-3483)\n            throw new error_1.MongoRuntimeError('ClientSession requires a MongoClient');\n        }\n        if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n            // TODO(NODE-3483)\n            throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');\n        }\n        options = options ?? {};\n        if (options.snapshot === true) {\n            this[kSnapshotEnabled] = true;\n            if (options.causalConsistency === true) {\n                throw new error_1.MongoInvalidArgumentError('Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive');\n            }\n        }\n        this.client = client;\n        this.sessionPool = sessionPool;\n        this.hasEnded = false;\n        this.clientOptions = clientOptions;\n        this.explicit = !!options.explicit;\n        this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;\n        this[kTxnNumberIncrement] = 0;\n        const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;\n        this.supports = {\n            // if we can enable causal consistency, do so by default\n            causalConsistency: options.causalConsistency ?? defaultCausalConsistencyValue\n        };\n        this.clusterTime = options.initialClusterTime;\n        this.operationTime = undefined;\n        this.owner = options.owner;\n        this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n        this.transaction = new transactions_1.Transaction();\n    }\n    /** The server id associated with this session */\n    get id() {\n        return this[kServerSession]?.id;\n    }\n    get serverSession() {\n        let serverSession = this[kServerSession];\n        if (serverSession == null) {\n            if (this.explicit) {\n                throw new error_1.MongoRuntimeError('Unexpected null serverSession for an explicit session');\n            }\n            if (this.hasEnded) {\n                throw new error_1.MongoRuntimeError('Unexpected null serverSession for an ended implicit session');\n            }\n            serverSession = this.sessionPool.acquire();\n            this[kServerSession] = serverSession;\n        }\n        return serverSession;\n    }\n    /** Whether or not this session is configured for snapshot reads */\n    get snapshotEnabled() {\n        return this[kSnapshotEnabled];\n    }\n    get loadBalanced() {\n        return this.client.topology?.description.type === common_1.TopologyType.LoadBalanced;\n    }\n    /** @internal */\n    get pinnedConnection() {\n        return this[kPinnedConnection];\n    }\n    /** @internal */\n    pin(conn) {\n        if (this[kPinnedConnection]) {\n            throw TypeError('Cannot pin multiple connections to the same session');\n        }\n        this[kPinnedConnection] = conn;\n        conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n    }\n    /** @internal */\n    unpin(options) {\n        if (this.loadBalanced) {\n            return maybeClearPinnedConnection(this, options);\n        }\n        this.transaction.unpinServer();\n    }\n    get isPinned() {\n        return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n    }\n    /**\n     * Ends this session on the server\n     *\n     * @param options - Optional settings. Currently reserved for future use\n     */\n    async endSession(options) {\n        try {\n            if (this.inTransaction()) {\n                await this.abortTransaction();\n            }\n            if (!this.hasEnded) {\n                const serverSession = this[kServerSession];\n                if (serverSession != null) {\n                    // release the server session back to the pool\n                    this.sessionPool.release(serverSession);\n                    // Make sure a new serverSession never makes it onto this ClientSession\n                    Object.defineProperty(this, kServerSession, {\n                        value: ServerSession.clone(serverSession),\n                        writable: false\n                    });\n                }\n                // mark the session as ended, and emit a signal\n                this.hasEnded = true;\n                this.emit('ended', this);\n            }\n        }\n        catch {\n            // spec indicates that we should ignore all errors for `endSessions`\n        }\n        finally {\n            maybeClearPinnedConnection(this, { force: true, ...options });\n        }\n    }\n    /**\n     * Advances the operationTime for a ClientSession.\n     *\n     * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n     */\n    advanceOperationTime(operationTime) {\n        if (this.operationTime == null) {\n            this.operationTime = operationTime;\n            return;\n        }\n        if (operationTime.greaterThan(this.operationTime)) {\n            this.operationTime = operationTime;\n        }\n    }\n    /**\n     * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n     *\n     * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n     */\n    advanceClusterTime(clusterTime) {\n        if (!clusterTime || typeof clusterTime !== 'object') {\n            throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');\n        }\n        if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n            throw new error_1.MongoInvalidArgumentError('input cluster time \"clusterTime\" property must be a valid BSON Timestamp');\n        }\n        if (!clusterTime.signature ||\n            clusterTime.signature.hash?._bsontype !== 'Binary' ||\n            (typeof clusterTime.signature.keyId !== 'bigint' &&\n                typeof clusterTime.signature.keyId !== 'number' &&\n                clusterTime.signature.keyId?._bsontype !== 'Long') // apparently we decode the key to number?\n        ) {\n            throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId');\n        }\n        (0, common_1._advanceClusterTime)(this, clusterTime);\n    }\n    /**\n     * Used to determine if this session equals another\n     *\n     * @param session - The session to compare to\n     */\n    equals(session) {\n        if (!(session instanceof ClientSession)) {\n            return false;\n        }\n        if (this.id == null || session.id == null) {\n            return false;\n        }\n        return utils_1.ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);\n    }\n    /**\n     * Increment the transaction number on the internal ServerSession\n     *\n     * @privateRemarks\n     * This helper increments a value stored on the client session that will be\n     * added to the serverSession's txnNumber upon applying it to a command.\n     * This is because the serverSession is lazily acquired after a connection is obtained\n     */\n    incrementTransactionNumber() {\n        this[kTxnNumberIncrement] += 1;\n    }\n    /** @returns whether this session is currently in a transaction or not */\n    inTransaction() {\n        return this.transaction.isActive;\n    }\n    /**\n     * Starts a new transaction with the given options.\n     *\n     * @param options - Options for the transaction\n     */\n    startTransaction(options) {\n        if (this[kSnapshotEnabled]) {\n            throw new error_1.MongoCompatibilityError('Transactions are not supported in snapshot sessions');\n        }\n        if (this.inTransaction()) {\n            throw new error_1.MongoTransactionError('Transaction already in progress');\n        }\n        if (this.isPinned && this.transaction.isCommitted) {\n            this.unpin();\n        }\n        const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);\n        if ((0, shared_1.isSharded)(this.client.topology) &&\n            topologyMaxWireVersion != null &&\n            topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n            throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n        }\n        // increment txnNumber\n        this.incrementTransactionNumber();\n        // create transaction state\n        this.transaction = new transactions_1.Transaction({\n            readConcern: options?.readConcern ??\n                this.defaultTransactionOptions.readConcern ??\n                this.clientOptions?.readConcern,\n            writeConcern: options?.writeConcern ??\n                this.defaultTransactionOptions.writeConcern ??\n                this.clientOptions?.writeConcern,\n            readPreference: options?.readPreference ??\n                this.defaultTransactionOptions.readPreference ??\n                this.clientOptions?.readPreference,\n            maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS\n        });\n        this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);\n    }\n    /**\n     * Commits the currently active transaction in this session.\n     */\n    async commitTransaction() {\n        return endTransactionAsync(this, 'commitTransaction');\n    }\n    /**\n     * Aborts the currently active transaction in this session.\n     */\n    async abortTransaction() {\n        return endTransactionAsync(this, 'abortTransaction');\n    }\n    /**\n     * This is here to ensure that ClientSession is never serialized to BSON.\n     */\n    toBSON() {\n        throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n    }\n    /**\n     * Starts a transaction and runs a provided function, ensuring the commitTransaction is always attempted when all operations run in the function have completed.\n     *\n     * **IMPORTANT:** This method requires the user to return a Promise, and `await` all operations.\n     *\n     * @remarks\n     * This function:\n     * - If all operations successfully complete and the `commitTransaction` operation is successful, then this function will return the result of the provided function.\n     * - If the transaction is unable to complete or an error is thrown from within the provided function, then this function will throw an error.\n     *   - If the transaction is manually aborted within the provided function it will not throw.\n     * - May be called multiple times if the driver needs to attempt to retry the operations.\n     *\n     * Checkout a descriptive example here:\n     * @see https://www.mongodb.com/blog/post/quick-start-nodejs--mongodb--how-to-implement-transactions\n     *\n     * @param fn - callback to run within a transaction\n     * @param options - optional settings for the transaction\n     * @returns A raw command response or undefined\n     */\n    async withTransaction(fn, options) {\n        const startTime = (0, utils_1.now)();\n        return attemptTransaction(this, startTime, fn, options);\n    }\n}\nexports.ClientSession = ClientSession;\n_a = kSnapshotEnabled;\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([\n    'CannotSatisfyWriteConcern',\n    'UnknownReplWriteConcern',\n    'UnsatisfiableWriteConcern'\n]);\nfunction hasNotTimedOut(startTime, max) {\n    return (0, utils_1.calculateDurationInMs)(startTime) < max;\n}\nfunction isUnknownTransactionCommitResult(err) {\n    const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError &&\n        err.codeName &&\n        NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n    return (isMaxTimeMSExpiredError(err) ||\n        (!isNonDeterministicWriteConcernError &&\n            err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern &&\n            err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern));\n}\nfunction maybeClearPinnedConnection(session, options) {\n    // unpin a connection if it has been pinned\n    const conn = session[kPinnedConnection];\n    const error = options?.error;\n    if (session.inTransaction() &&\n        error &&\n        error instanceof error_1.MongoError &&\n        error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n        return;\n    }\n    const topology = session.client.topology;\n    // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n    //       to validate that we don't unpin on _all_ errors?\n    if (conn && topology != null) {\n        const servers = Array.from(topology.s.servers.values());\n        const loadBalancer = servers[0];\n        if (options?.error == null || options?.force) {\n            loadBalancer.pool.checkIn(conn);\n            conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION\n                ? metrics_1.ConnectionPoolMetrics.TXN\n                : metrics_1.ConnectionPoolMetrics.CURSOR);\n            if (options?.forceClear) {\n                loadBalancer.pool.clear({ serviceId: conn.serviceId });\n            }\n        }\n        session[kPinnedConnection] = undefined;\n    }\n}\nexports.maybeClearPinnedConnection = maybeClearPinnedConnection;\nfunction isMaxTimeMSExpiredError(err) {\n    if (err == null || !(err instanceof error_1.MongoServerError)) {\n        return false;\n    }\n    return (err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired ||\n        (err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired));\n}\nfunction attemptTransactionCommit(session, startTime, fn, result, options) {\n    return session.commitTransaction().then(() => result, (err) => {\n        if (err instanceof error_1.MongoError &&\n            hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) &&\n            !isMaxTimeMSExpiredError(err)) {\n            if (err.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult)) {\n                return attemptTransactionCommit(session, startTime, fn, result, options);\n            }\n            if (err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n                return attemptTransaction(session, startTime, fn, options);\n            }\n        }\n        throw err;\n    });\n}\nconst USER_EXPLICIT_TXN_END_STATES = new Set([\n    transactions_1.TxnState.NO_TRANSACTION,\n    transactions_1.TxnState.TRANSACTION_COMMITTED,\n    transactions_1.TxnState.TRANSACTION_ABORTED\n]);\nfunction userExplicitlyEndedTransaction(session) {\n    return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\nfunction attemptTransaction(session, startTime, fn, options = {}) {\n    session.startTransaction(options);\n    let promise;\n    try {\n        promise = fn(session);\n    }\n    catch (err) {\n        promise = Promise.reject(err);\n    }\n    if (!(0, utils_1.isPromiseLike)(promise)) {\n        session.abortTransaction().catch(() => null);\n        return Promise.reject(new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise'));\n    }\n    return promise.then(result => {\n        if (userExplicitlyEndedTransaction(session)) {\n            return result;\n        }\n        return attemptTransactionCommit(session, startTime, fn, result, options);\n    }, err => {\n        function maybeRetryOrThrow(err) {\n            if (err instanceof error_1.MongoError &&\n                err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) &&\n                hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n                return attemptTransaction(session, startTime, fn, options);\n            }\n            if (isMaxTimeMSExpiredError(err)) {\n                err.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n            }\n            throw err;\n        }\n        if (session.inTransaction()) {\n            return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n        }\n        return maybeRetryOrThrow(err);\n    });\n}\nconst endTransactionAsync = (0, util_1.promisify)(endTransaction);\nfunction endTransaction(session, commandName, callback) {\n    // handle any initial problematic cases\n    const txnState = session.transaction.state;\n    if (txnState === transactions_1.TxnState.NO_TRANSACTION) {\n        callback(new error_1.MongoTransactionError('No transaction started'));\n        return;\n    }\n    if (commandName === 'commitTransaction') {\n        if (txnState === transactions_1.TxnState.STARTING_TRANSACTION ||\n            txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n            // the transaction was never started, we can safely exit here\n            session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);\n            callback();\n            return;\n        }\n        if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n            callback(new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction'));\n            return;\n        }\n    }\n    else {\n        if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {\n            // the transaction was never started, we can safely exit here\n            session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n            callback();\n            return;\n        }\n        if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n            callback(new error_1.MongoTransactionError('Cannot call abortTransaction twice'));\n            return;\n        }\n        if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED ||\n            txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n            callback(new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction'));\n            return;\n        }\n    }\n    // construct and send the command\n    const command = { [commandName]: 1 };\n    // apply a writeConcern if specified\n    let writeConcern;\n    if (session.transaction.options.writeConcern) {\n        writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n    }\n    else if (session.clientOptions && session.clientOptions.writeConcern) {\n        writeConcern = { w: session.clientOptions.writeConcern.w };\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {\n        writeConcern = Object.assign({ wtimeoutMS: 10000 }, writeConcern, { w: 'majority' });\n    }\n    if (writeConcern) {\n        write_concern_1.WriteConcern.apply(command, writeConcern);\n    }\n    if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n        Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });\n    }\n    function commandHandler(error) {\n        if (commandName !== 'commitTransaction') {\n            session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n            if (session.loadBalanced) {\n                maybeClearPinnedConnection(session, { force: false });\n            }\n            // The spec indicates that we should ignore all errors on `abortTransaction`\n            return callback();\n        }\n        session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n        if (error instanceof error_1.MongoError) {\n            if ((0, error_1.isRetryableWriteError)(error) ||\n                error instanceof error_1.MongoWriteConcernError ||\n                isMaxTimeMSExpiredError(error)) {\n                if (isUnknownTransactionCommitResult(error)) {\n                    error.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n                    // per txns spec, must unpin session in this case\n                    session.unpin({ error });\n                }\n            }\n            else if (error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n                session.unpin({ error });\n            }\n        }\n        callback(error);\n    }\n    if (session.transaction.recoveryToken) {\n        command.recoveryToken = session.transaction.recoveryToken;\n    }\n    // send the command\n    (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(command, {\n        session,\n        readPreference: read_preference_1.ReadPreference.primary,\n        bypassPinningCheck: true\n    }), error => {\n        if (command.abortTransaction) {\n            // always unpin on abort regardless of command outcome\n            session.unpin();\n        }\n        if (error instanceof error_1.MongoError && (0, error_1.isRetryableWriteError)(error)) {\n            // SPEC-1185: apply majority write concern when retrying commitTransaction\n            if (command.commitTransaction) {\n                // per txns spec, must unpin session in this case\n                session.unpin({ force: true });\n                command.writeConcern = Object.assign({ wtimeout: 10000 }, command.writeConcern, {\n                    w: 'majority'\n                });\n            }\n            return (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(command, {\n                session,\n                readPreference: read_preference_1.ReadPreference.primary,\n                bypassPinningCheck: true\n            }), commandHandler);\n        }\n        commandHandler(error);\n    });\n}\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\nclass ServerSession {\n    /** @internal */\n    constructor() {\n        this.id = { id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID) };\n        this.lastUse = (0, utils_1.now)();\n        this.txnNumber = 0;\n        this.isDirty = false;\n    }\n    /**\n     * Determines if the server session has timed out.\n     *\n     * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n     */\n    hasTimedOut(sessionTimeoutMinutes) {\n        // Take the difference of the lastUse timestamp and now, which will result in a value in\n        // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n        const idleTimeMinutes = Math.round((((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000) % 3600000) / 60000);\n        return idleTimeMinutes > sessionTimeoutMinutes - 1;\n    }\n    /**\n     * @internal\n     * Cloning meant to keep a readable reference to the server session data\n     * after ClientSession has ended\n     */\n    static clone(serverSession) {\n        const arrayBuffer = new ArrayBuffer(16);\n        const idBytes = Buffer.from(arrayBuffer);\n        idBytes.set(serverSession.id.id.buffer);\n        const id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type);\n        // Manual prototype construction to avoid modifying the constructor of this class\n        return Object.setPrototypeOf({\n            id: { id },\n            lastUse: serverSession.lastUse,\n            txnNumber: serverSession.txnNumber,\n            isDirty: serverSession.isDirty\n        }, ServerSession.prototype);\n    }\n}\nexports.ServerSession = ServerSession;\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\nclass ServerSessionPool {\n    constructor(client) {\n        if (client == null) {\n            throw new error_1.MongoRuntimeError('ServerSessionPool requires a MongoClient');\n        }\n        this.client = client;\n        this.sessions = new utils_1.List();\n    }\n    /**\n     * Acquire a Server Session from the pool.\n     * Iterates through each session in the pool, removing any stale sessions\n     * along the way. The first non-stale session found is removed from the\n     * pool and returned. If no non-stale session is found, a new ServerSession is created.\n     */\n    acquire() {\n        const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n        let session = null;\n        // Try to obtain from session pool\n        while (this.sessions.length > 0) {\n            const potentialSession = this.sessions.shift();\n            if (potentialSession != null &&\n                (!!this.client.topology?.loadBalanced ||\n                    !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {\n                session = potentialSession;\n                break;\n            }\n        }\n        // If nothing valid came from the pool make a new one\n        if (session == null) {\n            session = new ServerSession();\n        }\n        return session;\n    }\n    /**\n     * Release a session to the session pool\n     * Adds the session back to the session pool if the session has not timed out yet.\n     * This method also removes any stale sessions from the pool.\n     *\n     * @param session - The session to release to the pool\n     */\n    release(session) {\n        const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n        if (this.client.topology?.loadBalanced && !sessionTimeoutMinutes) {\n            this.sessions.unshift(session);\n        }\n        if (!sessionTimeoutMinutes) {\n            return;\n        }\n        this.sessions.prune(session => session.hasTimedOut(sessionTimeoutMinutes));\n        if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n            if (session.isDirty) {\n                return;\n            }\n            // otherwise, readd this session to the session pool\n            this.sessions.unshift(session);\n        }\n    }\n}\nexports.ServerSessionPool = ServerSessionPool;\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n *\n * @internal\n */\nfunction applySession(session, command, options) {\n    if (session.hasEnded) {\n        return new error_1.MongoExpiredSessionError();\n    }\n    // May acquire serverSession here\n    const serverSession = session.serverSession;\n    if (serverSession == null) {\n        return new error_1.MongoRuntimeError('Unable to acquire server session');\n    }\n    if (options.writeConcern?.w === 0) {\n        if (session && session.explicit) {\n            // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)\n            return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');\n        }\n        return;\n    }\n    // mark the last use of this session, and apply the `lsid`\n    serverSession.lastUse = (0, utils_1.now)();\n    command.lsid = serverSession.id;\n    const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);\n    const isRetryableWrite = !!options.willRetryWrite;\n    if (isRetryableWrite || inTxnOrTxnCommand) {\n        serverSession.txnNumber += session[kTxnNumberIncrement];\n        session[kTxnNumberIncrement] = 0;\n        // TODO(NODE-2674): Preserve int64 sent from MongoDB\n        command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);\n    }\n    if (!inTxnOrTxnCommand) {\n        if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {\n            session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);\n        }\n        if (session.supports.causalConsistency &&\n            session.operationTime &&\n            (0, utils_1.commandSupportsReadConcern)(command)) {\n            command.readConcern = command.readConcern || {};\n            Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n        }\n        else if (session[kSnapshotEnabled]) {\n            command.readConcern = command.readConcern || { level: read_concern_1.ReadConcernLevel.snapshot };\n            if (session[kSnapshotTime] != null) {\n                Object.assign(command.readConcern, { atClusterTime: session[kSnapshotTime] });\n            }\n        }\n        return;\n    }\n    // now attempt to apply transaction-specific sessions data\n    // `autocommit` must always be false to differentiate from retryable writes\n    command.autocommit = false;\n    if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {\n        session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);\n        command.startTransaction = true;\n        const readConcern = session.transaction.options.readConcern || session?.clientOptions?.readConcern;\n        if (readConcern) {\n            command.readConcern = readConcern;\n        }\n        if (session.supports.causalConsistency && session.operationTime) {\n            command.readConcern = command.readConcern || {};\n            Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n        }\n    }\n    return;\n}\nexports.applySession = applySession;\nfunction updateSessionFromResponse(session, document) {\n    if (document.$clusterTime) {\n        (0, common_1._advanceClusterTime)(session, document.$clusterTime);\n    }\n    if (document.operationTime && session && session.supports.causalConsistency) {\n        session.advanceOperationTime(document.operationTime);\n    }\n    if (document.recoveryToken && session && session.inTransaction()) {\n        session.transaction._recoveryToken = document.recoveryToken;\n    }\n    if (session?.[kSnapshotEnabled] && session[kSnapshotTime] == null) {\n        // find and aggregate commands return atClusterTime on the cursor\n        // distinct includes it in the response body\n        const atClusterTime = document.cursor?.atClusterTime || document.atClusterTime;\n        if (atClusterTime) {\n            session[kSnapshotTime] = atClusterTime;\n        }\n    }\n}\nexports.updateSessionFromResponse = updateSessionFromResponse;\n//# sourceMappingURL=sessions.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}