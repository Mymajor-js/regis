{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isSharded = exports.getReadPreference = void 0;\nconst error_1 = require(\"../../error\");\nconst read_preference_1 = require(\"../../read_preference\");\nconst common_1 = require(\"../../sdam/common\");\nconst topology_description_1 = require(\"../../sdam/topology_description\");\nfunction getReadPreference(options) {\n  // Default to command version of the readPreference\n  let readPreference = options?.readPreference ?? read_preference_1.ReadPreference.primary;\n  // If we have an option readPreference override the command one\n  if (options?.readPreference) {\n    readPreference = options.readPreference;\n  }\n  if (typeof readPreference === 'string') {\n    readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n  }\n  if (!(readPreference instanceof read_preference_1.ReadPreference)) {\n    throw new error_1.MongoInvalidArgumentError('Option \"readPreference\" must be a ReadPreference instance');\n  }\n  return readPreference;\n}\nexports.getReadPreference = getReadPreference;\nfunction isSharded(topologyOrServer) {\n  if (topologyOrServer == null) {\n    return false;\n  }\n  if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {\n    return true;\n  }\n  // NOTE: This is incredibly inefficient, and should be removed once command construction\n  //       happens based on `Server` not `Topology`.\n  if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {\n    const servers = Array.from(topologyOrServer.description.servers.values());\n    return servers.some(server => server.type === common_1.ServerType.Mongos);\n  }\n  return false;\n}\nexports.isSharded = isSharded;","map":{"version":3,"names":["Object","defineProperty","exports","value","isSharded","getReadPreference","error_1","require","read_preference_1","common_1","topology_description_1","options","readPreference","ReadPreference","primary","fromString","MongoInvalidArgumentError","topologyOrServer","description","type","ServerType","Mongos","TopologyDescription","servers","Array","from","values","some","server"],"sources":["D:/web_project/node_modules/mongodb/lib/cmap/wire_protocol/shared.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isSharded = exports.getReadPreference = void 0;\nconst error_1 = require(\"../../error\");\nconst read_preference_1 = require(\"../../read_preference\");\nconst common_1 = require(\"../../sdam/common\");\nconst topology_description_1 = require(\"../../sdam/topology_description\");\nfunction getReadPreference(options) {\n    // Default to command version of the readPreference\n    let readPreference = options?.readPreference ?? read_preference_1.ReadPreference.primary;\n    // If we have an option readPreference override the command one\n    if (options?.readPreference) {\n        readPreference = options.readPreference;\n    }\n    if (typeof readPreference === 'string') {\n        readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n    }\n    if (!(readPreference instanceof read_preference_1.ReadPreference)) {\n        throw new error_1.MongoInvalidArgumentError('Option \"readPreference\" must be a ReadPreference instance');\n    }\n    return readPreference;\n}\nexports.getReadPreference = getReadPreference;\nfunction isSharded(topologyOrServer) {\n    if (topologyOrServer == null) {\n        return false;\n    }\n    if (topologyOrServer.description && topologyOrServer.description.type === common_1.ServerType.Mongos) {\n        return true;\n    }\n    // NOTE: This is incredibly inefficient, and should be removed once command construction\n    //       happens based on `Server` not `Topology`.\n    if (topologyOrServer.description && topologyOrServer.description instanceof topology_description_1.TopologyDescription) {\n        const servers = Array.from(topologyOrServer.description.servers.values());\n        return servers.some((server) => server.type === common_1.ServerType.Mongos);\n    }\n    return false;\n}\nexports.isSharded = isSharded;\n//# sourceMappingURL=shared.js.map"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,SAAS,GAAGF,OAAO,CAACG,iBAAiB,GAAG,KAAK,CAAC;AACtD,MAAMC,OAAO,GAAGC,OAAO,CAAC,aAAa,CAAC;AACtC,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,uBAAuB,CAAC;AAC1D,MAAME,QAAQ,GAAGF,OAAO,CAAC,mBAAmB,CAAC;AAC7C,MAAMG,sBAAsB,GAAGH,OAAO,CAAC,iCAAiC,CAAC;AACzE,SAASF,iBAAiBA,CAACM,OAAO,EAAE;EAChC;EACA,IAAIC,cAAc,GAAGD,OAAO,EAAEC,cAAc,IAAIJ,iBAAiB,CAACK,cAAc,CAACC,OAAO;EACxF;EACA,IAAIH,OAAO,EAAEC,cAAc,EAAE;IACzBA,cAAc,GAAGD,OAAO,CAACC,cAAc;EAC3C;EACA,IAAI,OAAOA,cAAc,KAAK,QAAQ,EAAE;IACpCA,cAAc,GAAGJ,iBAAiB,CAACK,cAAc,CAACE,UAAU,CAACH,cAAc,CAAC;EAChF;EACA,IAAI,EAAEA,cAAc,YAAYJ,iBAAiB,CAACK,cAAc,CAAC,EAAE;IAC/D,MAAM,IAAIP,OAAO,CAACU,yBAAyB,CAAC,2DAA2D,CAAC;EAC5G;EACA,OAAOJ,cAAc;AACzB;AACAV,OAAO,CAACG,iBAAiB,GAAGA,iBAAiB;AAC7C,SAASD,SAASA,CAACa,gBAAgB,EAAE;EACjC,IAAIA,gBAAgB,IAAI,IAAI,EAAE;IAC1B,OAAO,KAAK;EAChB;EACA,IAAIA,gBAAgB,CAACC,WAAW,IAAID,gBAAgB,CAACC,WAAW,CAACC,IAAI,KAAKV,QAAQ,CAACW,UAAU,CAACC,MAAM,EAAE;IAClG,OAAO,IAAI;EACf;EACA;EACA;EACA,IAAIJ,gBAAgB,CAACC,WAAW,IAAID,gBAAgB,CAACC,WAAW,YAAYR,sBAAsB,CAACY,mBAAmB,EAAE;IACpH,MAAMC,OAAO,GAAGC,KAAK,CAACC,IAAI,CAACR,gBAAgB,CAACC,WAAW,CAACK,OAAO,CAACG,MAAM,CAAC,CAAC,CAAC;IACzE,OAAOH,OAAO,CAACI,IAAI,CAAEC,MAAM,IAAKA,MAAM,CAACT,IAAI,KAAKV,QAAQ,CAACW,UAAU,CAACC,MAAM,CAAC;EAC/E;EACA,OAAO,KAAK;AAChB;AACAnB,OAAO,CAACE,SAAS,GAAGA,SAAS","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}